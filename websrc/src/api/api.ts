/* tslint:disable */
/* eslint-disable */
/**
 * kafka_executor
 * This customizable load generator will create producers and consumers. Features include controllable parallel execution of different workloads. There is an easy-to-use Swagger front end that can be used to integrate with other programming languages such as React, Angular, Python... The intention is to use JMeter or even siege to run and monitor the tests using simple http calls. 
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface About
 */
export interface About {
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'Version'?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'CurrentDateTime'?: string;
}
/**
 * 
 * @export
 * @interface BatchStatus
 */
export interface BatchStatus {
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'CurrentDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'BatchName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'BatchType'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchStatus
     */
    'RunningJobs'?: number;
}
/**
 * 
 * @export
 * @interface ClassStatistic
 */
export interface ClassStatistic {
    /**
     * 
     * @type {string}
     * @memberof ClassStatistic
     */
    'className'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'consumerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'consumerAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'producerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'producerAmount'?: number;
}
/**
 * 
 * @export
 * @interface ConnectionConfigDTO
 */
export interface ConnectionConfigDTO {
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'port'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'cert_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'truststore_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'keystore_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'schemaRegistryHost'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'schemaRegistryPort'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'schemaRegistryUser'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'schemaRegistryPassword'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'producerLingerMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'producerBatchSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'compressionType'?: ConnectionConfigDTOCompressionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'bufferMemory'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectionConfigDTO
     */
    'idempotenceEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConnectionConfigDTO
     */
    'acks'?: ConnectionConfigDTOAcksEnum;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'maxPollRecords'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'fetchMinByes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'fetchMaxWaitMS'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'sessionTimeoutMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'heartbeatTimeoutMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectionConfigDTO
     */
    'autoCommitIntervalMs'?: number;
}

export const ConnectionConfigDTOCompressionTypeEnum = {
    None: 'none',
    Gzip: 'gzip',
    Snappy: 'snappy',
    Lz4: 'lz4',
    Zstd: 'zstd'
} as const;

export type ConnectionConfigDTOCompressionTypeEnum = typeof ConnectionConfigDTOCompressionTypeEnum[keyof typeof ConnectionConfigDTOCompressionTypeEnum];
export const ConnectionConfigDTOAcksEnum = {
    All: 'all',
    _1: '1',
    _0: '0'
} as const;

export type ConnectionConfigDTOAcksEnum = typeof ConnectionConfigDTOAcksEnum[keyof typeof ConnectionConfigDTOAcksEnum];

/**
 * 
 * @export
 * @interface ConsumerStatus
 */
export interface ConsumerStatus {
    /**
     * 
     * @type {string}
     * @memberof ConsumerStatus
     */
    'CurrentDateTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConsumerStatus
     */
    'Error'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConsumerStatus
     */
    'ErrorMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsumerStatus
     */
    'Status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConsumerStatus
     */
    'Count'?: number;
}
/**
 * 
 * @export
 * @interface ProducerStatus
 */
export interface ProducerStatus {
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'CurrentDateTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProducerStatus
     */
    'Error'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'ErrorMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'Status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProducerStatus
     */
    'Count'?: number;
}

/**
 * BatchControllerApi - axios parameter creator
 * @export
 */
export const BatchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeConsumerTaskCount: async (taskName?: string, numThreads?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/changeConsumerTaskCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeProducerTaskCount: async (taskName?: string, numThreads?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/changeProducerTaskCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [numThreads] 
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsumerTask: async (topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/generateConsumerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (maxTries !== undefined) {
                localVarQueryParameter['maxTries'] = maxTries;
            }

            if (sleepMillis !== undefined) {
                localVarQueryParameter['sleepMillis'] = sleepMillis;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [numThreads] 
         * @param {number} [batchSize] 
         * @param {number} [startId] 
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProducerTask: async (topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/generateProducerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (correlatedStartIdInc !== undefined) {
                localVarQueryParameter['correlatedStartIdInc'] = correlatedStartIdInc;
            }

            if (correlatedEndIdInc !== undefined) {
                localVarQueryParameter['correlatedEndIdInc'] = correlatedEndIdInc;
            }

            if (sleepMillis !== undefined) {
                localVarQueryParameter['sleepMillis'] = sleepMillis;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropConsumerTask: async (taskName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/dropConsumerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropProducerTask: async (taskName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/dropProducerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchStatuses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/batchStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClean2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/stopAllTasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsumers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/list/consumers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/list/producers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchControllerApi - functional programming interface
 * @export
 */
export const BatchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeConsumerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeConsumerTaskCount(taskName, numThreads, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.changeConsumerTaskCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeProducerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeProducerTaskCount(taskName, numThreads, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.changeProducerTaskCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [numThreads] 
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.createConsumerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [numThreads] 
         * @param {number} [batchSize] 
         * @param {number} [startId] 
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.createProducerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropConsumerTask(taskName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropConsumerTask(taskName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.dropConsumerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropProducerTask(taskName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropProducerTask(taskName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.dropProducerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchStatuses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchStatuses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.getBatchStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClean2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClean2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.getClean2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsumers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsumers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.getConsumers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.getProducers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchControllerApi - factory interface
 * @export
 */
export const BatchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeConsumerTaskCount(taskName?: string, numThreads?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.changeConsumerTaskCount(taskName, numThreads, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeProducerTaskCount(taskName?: string, numThreads?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.changeProducerTaskCount(taskName, numThreads, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [numThreads] 
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.createConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [numThreads] 
         * @param {number} [batchSize] 
         * @param {number} [startId] 
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.createProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropConsumerTask(taskName?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.dropConsumerTask(taskName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropProducerTask(taskName?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.dropProducerTask(taskName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchStatuses(options?: any): AxiosPromise<Array<BatchStatus>> {
            return localVarFp.getBatchStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClean2(options?: any): AxiosPromise<string> {
            return localVarFp.getClean2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsumers(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getConsumers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducers(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getProducers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchControllerApi - object-oriented interface
 * @export
 * @class BatchControllerApi
 * @extends {BaseAPI}
 */
export class BatchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [taskName] 
     * @param {number} [numThreads] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public changeConsumerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).changeConsumerTaskCount(taskName, numThreads, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [taskName] 
     * @param {number} [numThreads] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public changeProducerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).changeProducerTaskCount(taskName, numThreads, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [topicName] 
     * @param {number} [numThreads] 
     * @param {number} [batchSize] 
     * @param {number} [maxTries] 
     * @param {number} [sleepMillis] 
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public createConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).createConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [topicName] 
     * @param {number} [numThreads] 
     * @param {number} [batchSize] 
     * @param {number} [startId] 
     * @param {number} [correlatedStartIdInc] 
     * @param {number} [correlatedEndIdInc] 
     * @param {number} [sleepMillis] 
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public createProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).createProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [taskName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public dropConsumerTask(taskName?: string, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).dropConsumerTask(taskName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [taskName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public dropProducerTask(taskName?: string, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).dropProducerTask(taskName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public getBatchStatuses(options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).getBatchStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public getClean2(options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).getClean2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public getConsumers(options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).getConsumers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public getProducers(options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).getProducers(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfigControllerApi - axios parameter creator
 * @export
 */
export const ConfigControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAckTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/ackTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompressionTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/compressionTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectionConfigDTO} connectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionConfig: async (connectionConfigDTO: ConnectionConfigDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionConfigDTO' is not null or undefined
            assertParamExists('updateConnectionConfig', 'connectionConfigDTO', connectionConfigDTO)
            const localVarPath = `/server/connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectionConfigDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigControllerApi - functional programming interface
 * @export
 */
export const ConfigControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAckTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAckTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigControllerApi.getAckTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompressionTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompressionTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigControllerApi.getCompressionTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionConfigDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigControllerApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ConnectionConfigDTO} connectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnectionConfig(connectionConfigDTO: ConnectionConfigDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnectionConfig(connectionConfigDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigControllerApi.updateConnectionConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigControllerApi - factory interface
 * @export
 */
export const ConfigControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAckTypes(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getAckTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompressionTypes(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getCompressionTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<ConnectionConfigDTO> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectionConfigDTO} connectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectionConfig(connectionConfigDTO: ConnectionConfigDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateConnectionConfig(connectionConfigDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigControllerApi - object-oriented interface
 * @export
 * @class ConfigControllerApi
 * @extends {BaseAPI}
 */
export class ConfigControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public getAckTypes(options?: RawAxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).getAckTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public getCompressionTypes(options?: RawAxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).getCompressionTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectionConfigDTO} connectionConfigDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public updateConnectionConfig(connectionConfigDTO: ConnectionConfigDTO, options?: RawAxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).updateConnectionConfig(connectionConfigDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConsumerControllerApi - axios parameter creator
 * @export
 */
export const ConsumerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClean1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/test/clean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [server] 
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus2: async (topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/generateLoad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (maxTries !== undefined) {
                localVarQueryParameter['maxTries'] = maxTries;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsumerControllerApi - functional programming interface
 * @export
 */
export const ConsumerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsumerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClean1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClean1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumerControllerApi.getClean1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumerControllerApi.getList2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [server] 
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus2(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsumerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus2(topicName, server, batchSize, maxTries, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumerControllerApi.getStatus2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConsumerControllerApi - factory interface
 * @export
 */
export const ConsumerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsumerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClean1(options?: any): AxiosPromise<string> {
            return localVarFp.getClean1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList2(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getList2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [server] 
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus2(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: any): AxiosPromise<ConsumerStatus> {
            return localVarFp.getStatus2(topicName, server, batchSize, maxTries, dataClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConsumerControllerApi - object-oriented interface
 * @export
 * @class ConsumerControllerApi
 * @extends {BaseAPI}
 */
export class ConsumerControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumerControllerApi
     */
    public getClean1(options?: RawAxiosRequestConfig) {
        return ConsumerControllerApiFp(this.configuration).getClean1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumerControllerApi
     */
    public getList2(options?: RawAxiosRequestConfig) {
        return ConsumerControllerApiFp(this.configuration).getList2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [topicName] 
     * @param {number} [server] 
     * @param {number} [batchSize] 
     * @param {number} [maxTries] 
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumerControllerApi
     */
    public getStatus2(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return ConsumerControllerApiFp(this.configuration).getStatus2(topicName, server, batchSize, maxTries, dataClass, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoControllerApi - axios parameter creator
 * @export
 */
export const InfoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoControllerApi - functional programming interface
 * @export
 */
export const InfoControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<About>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoControllerApi.getStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoControllerApi - factory interface
 * @export
 */
export const InfoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus1(options?: any): AxiosPromise<About> {
            return localVarFp.getStatus1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoControllerApi - object-oriented interface
 * @export
 * @class InfoControllerApi
 * @extends {BaseAPI}
 */
export class InfoControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoControllerApi
     */
    public getStatus1(options?: RawAxiosRequestConfig) {
        return InfoControllerApiFp(this.configuration).getStatus1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogControllerApi - axios parameter creator
 * @export
 */
export const LogControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList1: async (className?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log/listClass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (className !== undefined) {
                localVarQueryParameter['className'] = className;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogControllerApi - functional programming interface
 * @export
 */
export const LogControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassStatistic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogControllerApi.getList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList1(className?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStatistic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList1(className, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogControllerApi.getList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogControllerApi - factory interface
 * @export
 */
export const LogControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(options?: any): AxiosPromise<Array<ClassStatistic>> {
            return localVarFp.getList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList1(className?: string, options?: any): AxiosPromise<ClassStatistic> {
            return localVarFp.getList1(className, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogControllerApi - object-oriented interface
 * @export
 * @class LogControllerApi
 * @extends {BaseAPI}
 */
export class LogControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getList(options?: RawAxiosRequestConfig) {
        return LogControllerApiFp(this.configuration).getList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [className] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getList1(className?: string, options?: RawAxiosRequestConfig) {
        return LogControllerApiFp(this.configuration).getList1(className, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProducerControllerApi - axios parameter creator
 * @export
 */
export const ProducerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {number} [partitions] 
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopics: async (topics?: Array<string>, partitions?: number, replication?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/createTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topics) {
                localVarQueryParameter['topics[]'] = topics;
            }

            if (partitions !== undefined) {
                localVarQueryParameter['partitions'] = partitions;
            }

            if (replication !== undefined) {
                localVarQueryParameter['replication'] = replication;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopics: async (topics?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/deleteTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topics) {
                localVarQueryParameter['topics[]'] = topics;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClean: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/clean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListDataClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listDataClasses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListTopics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [server] 
         * @param {number} [batchSize] 
         * @param {number} [startId] 
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGenerateLoad: async (topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/generateLoad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (correlatedStartIdInc !== undefined) {
                localVarQueryParameter['correlatedStartIdInc'] = correlatedStartIdInc;
            }

            if (correlatedEndIdInc !== undefined) {
                localVarQueryParameter['correlatedEndIdInc'] = correlatedEndIdInc;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProducerControllerApi - functional programming interface
 * @export
 */
export const ProducerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProducerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {number} [partitions] 
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTopics(topics, partitions, replication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.createTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTopics(topics?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTopics(topics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.deleteTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClean(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClean(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.getClean']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListDataClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListDataClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.getListDataClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListTopics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListTopics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.getListTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [server] 
         * @param {number} [batchSize] 
         * @param {number} [startId] 
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGenerateLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGenerateLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.putGenerateLoad']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProducerControllerApi - factory interface
 * @export
 */
export const ProducerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProducerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {number} [partitions] 
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: any): AxiosPromise<object> {
            return localVarFp.createTopics(topics, partitions, replication, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopics(topics?: Array<string>, options?: any): AxiosPromise<object> {
            return localVarFp.deleteTopics(topics, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClean(options?: any): AxiosPromise<string> {
            return localVarFp.getClean(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListDataClasses(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getListDataClasses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListTopics(options?: any): AxiosPromise<Set<string>> {
            return localVarFp.getListTopics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [topicName] 
         * @param {number} [server] 
         * @param {number} [batchSize] 
         * @param {number} [startId] 
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGenerateLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: any): AxiosPromise<ProducerStatus> {
            return localVarFp.putGenerateLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProducerControllerApi - object-oriented interface
 * @export
 * @class ProducerControllerApi
 * @extends {BaseAPI}
 */
export class ProducerControllerApi extends BaseAPI {
    /**
     * 
     * @param {Array<string>} [topics] 
     * @param {number} [partitions] 
     * @param {number} [replication] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public createTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).createTopics(topics, partitions, replication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [topics] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public deleteTopics(topics?: Array<string>, options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).deleteTopics(topics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public getClean(options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).getClean(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public getListDataClasses(options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).getListDataClasses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public getListTopics(options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).getListTopics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [topicName] 
     * @param {number} [server] 
     * @param {number} [batchSize] 
     * @param {number} [startId] 
     * @param {number} [correlatedStartIdInc] 
     * @param {number} [correlatedEndIdInc] 
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public putGenerateLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).putGenerateLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options).then((request) => request(this.axios, this.basePath));
    }
}



