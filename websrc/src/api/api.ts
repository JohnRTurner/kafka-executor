/* tslint:disable */
/* eslint-disable */
/**
 * kafka_executor
 * This customizable load generator will create producers and consumers. Features include controllable parallel execution of different workloads. There is an easy-to-use Swagger front end that can be used to integrate with other programming languages such as React, Angular, Python... The intention is to use JMeter or even siege to run and monitor the tests using simple http calls. 
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type {Configuration} from './configuration';
import type {AxiosInstance, AxiosPromise, RawAxiosRequestConfig} from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
    assertParamExists,
    createRequestFunction,
    DUMMY_BASE_URL,
    serializeDataIfNeeded,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    toPathString
} from './common';
import type {RequestArgs} from './base';
// @ts-ignore
import {BASE_PATH, BaseAPI, COLLECTION_FORMATS, operationServerMap, RequiredError} from './base';

/**
 * 
 * @export
 * @interface About
 */
export interface About {
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'Version'?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'CurrentDateTime'?: string;
}
/**
 * 
 * @export
 * @interface BatchStatus
 */
export interface BatchStatus {
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'CurrentDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'BatchName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'BatchType'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchStatus
     */
    'RunningJobs'?: number;
}
/**
 * 
 * @export
 * @interface ClassStatistic
 */
export interface ClassStatistic {
    /**
     * 
     * @type {string}
     * @memberof ClassStatistic
     */
    'className'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'consumerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'consumerAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'producerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'producerAmount'?: number;
}
/**
 * 
 * @export
 * @interface ConsumerStatus
 */
export interface ConsumerStatus {
    /**
     * 
     * @type {string}
     * @memberof ConsumerStatus
     */
    'CurrentDateTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConsumerStatus
     */
    'Error'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConsumerStatus
     */
    'ErrorMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsumerStatus
     */
    'Status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConsumerStatus
     */
    'Count'?: number;
}
/**
 * 
 * @export
 * @interface KafkaConnectionConfigDTO
 */
export interface KafkaConnectionConfigDTO {
    /**
     * 
     * @type {boolean}
     * @memberof KafkaConnectionConfigDTO
     */
    'enable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'port'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'cert_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'truststore_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'keystore_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'schemaRegistryHost'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'schemaRegistryPort'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'schemaRegistryUser'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'schemaRegistryPassword'?: string;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'producerLingerMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'producerBatchSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'compressionType'?: KafkaConnectionConfigDTOCompressionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'bufferMemory'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof KafkaConnectionConfigDTO
     */
    'idempotenceEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'acks'?: KafkaConnectionConfigDTOAcksEnum;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'maxPollRecords'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'fetchMinByes'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'fetchMaxWaitMS'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'sessionTimeoutMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'heartbeatTimeoutMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'autoCommitIntervalMs'?: number;
}

export const KafkaConnectionConfigDTOCompressionTypeEnum = {
    None: 'none',
    Gzip: 'gzip',
    Snappy: 'snappy',
    Lz4: 'lz4',
    Zstd: 'zstd'
} as const;

export type KafkaConnectionConfigDTOCompressionTypeEnum = typeof KafkaConnectionConfigDTOCompressionTypeEnum[keyof typeof KafkaConnectionConfigDTOCompressionTypeEnum];
export const KafkaConnectionConfigDTOAcksEnum = {
    All: 'all',
    _1: '1',
    _0: '0'
} as const;

export type KafkaConnectionConfigDTOAcksEnum = typeof KafkaConnectionConfigDTOAcksEnum[keyof typeof KafkaConnectionConfigDTOAcksEnum];

/**
 * 
 * @export
 * @interface OpenSearchConnectionDTO
 */
export interface OpenSearchConnectionDTO {
    /**
     * 
     * @type {boolean}
     * @memberof OpenSearchConnectionDTO
     */
    'enable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenSearchConnectionDTO
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof OpenSearchConnectionDTO
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof OpenSearchConnectionDTO
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenSearchConnectionDTO
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ProducerStatus
 */
export interface ProducerStatus {
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'CurrentDateTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProducerStatus
     */
    'Error'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'ErrorMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'Status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProducerStatus
     */
    'Count'?: number;
}

/**
 * RestBatchControllerApi - axios parameter creator
 * @export
 */
export const RestBatchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/batchStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeKafkaConsumerTaskCount: async (taskName?: string, numThreads?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/changeKafkaConsumerTaskCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeKafkaProducerTaskCount: async (taskName?: string, numThreads?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/changeKafkaProducerTaskCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropKafkaConsumerTask: async (taskName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/dropKafkaConsumerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropKafkaProducerTask: async (taskName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/dropKafkaProducerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [maxTries] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaConsumerTask: async (topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/generateKafkaConsumerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (maxTries !== undefined) {
                localVarQueryParameter['maxTries'] = maxTries;
            }

            if (sleepMillis !== undefined) {
                localVarQueryParameter['sleepMillis'] = sleepMillis;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaProducerTask: async (topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/generateKafkaProducerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (correlatedStartIdInc !== undefined) {
                localVarQueryParameter['correlatedStartIdInc'] = correlatedStartIdInc;
            }

            if (correlatedEndIdInc !== undefined) {
                localVarQueryParameter['correlatedEndIdInc'] = correlatedEndIdInc;
            }

            if (sleepMillis !== undefined) {
                localVarQueryParameter['sleepMillis'] = sleepMillis;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaConsumers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/listKafkaConsumers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaProducers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/listKafkaProducers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/stopAllTasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestBatchControllerApi - functional programming interface
 * @export
 */
export const RestBatchControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RestBatchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.batchStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeKafkaConsumerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeKafkaConsumerTaskCount(taskName, numThreads, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.changeKafkaConsumerTaskCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeKafkaProducerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeKafkaProducerTaskCount(taskName, numThreads, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.changeKafkaProducerTaskCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropKafkaConsumerTask(taskName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropKafkaConsumerTask(taskName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.dropKafkaConsumerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropKafkaProducerTask(taskName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropKafkaProducerTask(taskName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.dropKafkaProducerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [maxTries] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKafkaConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKafkaConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.generateKafkaConsumerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKafkaProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKafkaProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.generateKafkaProducerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkaConsumers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkaConsumers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.listKafkaConsumers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkaProducers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkaProducers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.listKafkaProducers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopAllTasks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopAllTasks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestBatchControllerApi.stopAllTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RestBatchControllerApi - factory interface
 * @export
 */
export const RestBatchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestBatchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchStatus(options?: any): AxiosPromise<Array<BatchStatus>> {
            return localVarFp.batchStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeKafkaConsumerTaskCount(taskName?: string, numThreads?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.changeKafkaConsumerTaskCount(taskName, numThreads, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeKafkaProducerTaskCount(taskName?: string, numThreads?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.changeKafkaProducerTaskCount(taskName, numThreads, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropKafkaConsumerTask(taskName?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.dropKafkaConsumerTask(taskName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropKafkaProducerTask(taskName?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.dropKafkaProducerTask(taskName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [maxTries] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.generateKafkaConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc] 
         * @param {number} [sleepMillis] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.generateKafkaProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaConsumers(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listKafkaConsumers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaProducers(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listKafkaProducers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks(options?: any): AxiosPromise<string> {
            return localVarFp.stopAllTasks(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestBatchControllerApi - object-oriented interface
 * @export
 * @class RestBatchControllerApi
 * @extends {BaseAPI}
 */
export class RestBatchControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public batchStatus(options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).batchStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [taskName] 
     * @param {number} [numThreads] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public changeKafkaConsumerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).changeKafkaConsumerTaskCount(taskName, numThreads, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [taskName] 
     * @param {number} [numThreads] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public changeKafkaProducerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).changeKafkaProducerTaskCount(taskName, numThreads, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [taskName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public dropKafkaConsumerTask(taskName?: string, options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).dropKafkaConsumerTask(taskName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [taskName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public dropKafkaProducerTask(taskName?: string, options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).dropKafkaProducerTask(taskName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [topicName]
     * @param {number} [numThreads]
     * @param {number} [batchSize]
     * @param {number} [maxTries] 
     * @param {number} [sleepMillis] 
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public generateKafkaConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).generateKafkaConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [topicName]
     * @param {number} [numThreads]
     * @param {number} [batchSize]
     * @param {number} [startId]
     * @param {number} [correlatedStartIdInc]
     * @param {number} [correlatedEndIdInc] 
     * @param {number} [sleepMillis] 
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public generateKafkaProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).generateKafkaProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public listKafkaConsumers(options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).listKafkaConsumers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public listKafkaProducers(options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).listKafkaProducers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestBatchControllerApi
     */
    public stopAllTasks(options?: RawAxiosRequestConfig) {
        return RestBatchControllerApiFp(this.configuration).stopAllTasks(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RestConfigControllerApi - axios parameter creator
 * @export
 */
export const RestConfigControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableKafka: async (body: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('enableKafka', 'body', body)
            const localVarPath = `/server/enableKafka`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableKafka1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/enableKafka`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableOpenSearch: async (body: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('enableOpenSearch', 'body', body)
            const localVarPath = `/server/enableOpenSearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableOpenSearch1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/enableOpenSearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaAckTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/kafkaAckTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaCompressionTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/kafkaCompressionTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {KafkaConnectionConfigDTO} kafkaConnectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaConnection: async (kafkaConnectionConfigDTO: KafkaConnectionConfigDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kafkaConnectionConfigDTO' is not null or undefined
            assertParamExists('kafkaConnection', 'kafkaConnectionConfigDTO', kafkaConnectionConfigDTO)
            const localVarPath = `/server/kafkaConnection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kafkaConnectionConfigDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaConnection1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/kafkaConnection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {OpenSearchConnectionDTO} openSearchConnectionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openSearchConnection: async (openSearchConnectionDTO: OpenSearchConnectionDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'openSearchConnectionDTO' is not null or undefined
            assertParamExists('openSearchConnection', 'openSearchConnectionDTO', openSearchConnectionDTO)
            const localVarPath = `/server/openSearchConnection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(openSearchConnectionDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openSearchConnection1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/openSearchConnection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestConfigControllerApi - functional programming interface
 * @export
 */
export const RestConfigControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RestConfigControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableKafka(body: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableKafka(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.enableKafka']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableKafka1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableKafka1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.enableKafka1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableOpenSearch(body: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableOpenSearch(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.enableOpenSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableOpenSearch1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableOpenSearch1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.enableOpenSearch1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kafkaAckTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{
            [key: string]: string;
        }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kafkaAckTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.kafkaAckTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kafkaCompressionTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kafkaCompressionTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.kafkaCompressionTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {KafkaConnectionConfigDTO} kafkaConnectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kafkaConnection(kafkaConnectionConfigDTO: KafkaConnectionConfigDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kafkaConnection(kafkaConnectionConfigDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.kafkaConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kafkaConnection1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KafkaConnectionConfigDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kafkaConnection1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.kafkaConnection1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {OpenSearchConnectionDTO} openSearchConnectionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openSearchConnection(openSearchConnectionDTO: OpenSearchConnectionDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openSearchConnection(openSearchConnectionDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.openSearchConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openSearchConnection1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenSearchConnectionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openSearchConnection1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConfigControllerApi.openSearchConnection1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RestConfigControllerApi - factory interface
 * @export
 */
export const RestConfigControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestConfigControllerApiFp(configuration)
    return {
        /**
         *
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableKafka(body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.enableKafka(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableKafka1(options?: any): AxiosPromise<boolean> {
            return localVarFp.enableKafka1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableOpenSearch(body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.enableOpenSearch(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableOpenSearch1(options?: any): AxiosPromise<boolean> {
            return localVarFp.enableOpenSearch1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaAckTypes(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.kafkaAckTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaCompressionTypes(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.kafkaCompressionTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {KafkaConnectionConfigDTO} kafkaConnectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaConnection(kafkaConnectionConfigDTO: KafkaConnectionConfigDTO, options?: any): AxiosPromise<void> {
            return localVarFp.kafkaConnection(kafkaConnectionConfigDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaConnection1(options?: any): AxiosPromise<KafkaConnectionConfigDTO> {
            return localVarFp.kafkaConnection1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {OpenSearchConnectionDTO} openSearchConnectionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openSearchConnection(openSearchConnectionDTO: OpenSearchConnectionDTO, options?: any): AxiosPromise<void> {
            return localVarFp.openSearchConnection(openSearchConnectionDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openSearchConnection1(options?: any): AxiosPromise<OpenSearchConnectionDTO> {
            return localVarFp.openSearchConnection1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestConfigControllerApi - object-oriented interface
 * @export
 * @class RestConfigControllerApi
 * @extends {BaseAPI}
 */
export class RestConfigControllerApi extends BaseAPI {
    /**
     *
     * @param {boolean} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public enableKafka(body: boolean, options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).enableKafka(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public enableKafka1(options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).enableKafka1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {boolean} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public enableOpenSearch(body: boolean, options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).enableOpenSearch(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public enableOpenSearch1(options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).enableOpenSearch1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public kafkaAckTypes(options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).kafkaAckTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public kafkaCompressionTypes(options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).kafkaCompressionTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KafkaConnectionConfigDTO} kafkaConnectionConfigDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public kafkaConnection(kafkaConnectionConfigDTO: KafkaConnectionConfigDTO, options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).kafkaConnection(kafkaConnectionConfigDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public kafkaConnection1(options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).kafkaConnection1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {OpenSearchConnectionDTO} openSearchConnectionDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public openSearchConnection(openSearchConnectionDTO: OpenSearchConnectionDTO, options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).openSearchConnection(openSearchConnectionDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConfigControllerApi
     */
    public openSearchConnection1(options?: RawAxiosRequestConfig) {
        return RestConfigControllerApiFp(this.configuration).openSearchConnection1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RestConsumerControllerApi - axios parameter creator
 * @export
 */
export const RestConsumerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanKafkaConnectionPool1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/cleanKafkaConnectionPool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanOpenSearchConnectionPool: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/cleanOpenSearchConnectionPool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaLoad1: async (topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/generateKafkaLoad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (maxTries !== undefined) {
                localVarQueryParameter['maxTries'] = maxTries;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [indexName]
         * @param {number} [startId]
         * @param {number} [endId]
         * @param {number} [batchSize]
         * @param {string} [dataClass]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOpenSearchLoad1: async (indexName?: string, startId?: number, endId?: number, batchSize?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/generateOpenSearchLoad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (indexName !== undefined) {
                localVarQueryParameter['indexName'] = indexName;
            }

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (endId !== undefined) {
                localVarQueryParameter['endId'] = endId;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestConsumerControllerApi - functional programming interface
 * @export
 */
export const RestConsumerControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RestConsumerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanKafkaConnectionPool1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanKafkaConnectionPool1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConsumerControllerApi.cleanKafkaConnectionPool1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanOpenSearchConnectionPool(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanOpenSearchConnectionPool(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConsumerControllerApi.cleanOpenSearchConnectionPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKafkaLoad1(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsumerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKafkaLoad1(topicName, server, batchSize, maxTries, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConsumerControllerApi.generateKafkaLoad1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [indexName]
         * @param {number} [startId]
         * @param {number} [endId]
         * @param {number} [batchSize]
         * @param {string} [dataClass]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateOpenSearchLoad1(indexName?: string, startId?: number, endId?: number, batchSize?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsumerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateOpenSearchLoad1(indexName, startId, endId, batchSize, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestConsumerControllerApi.generateOpenSearchLoad1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RestConsumerControllerApi - factory interface
 * @export
 */
export const RestConsumerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestConsumerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanKafkaConnectionPool1(options?: any): AxiosPromise<string> {
            return localVarFp.cleanKafkaConnectionPool1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanOpenSearchConnectionPool(options?: any): AxiosPromise<string> {
            return localVarFp.cleanOpenSearchConnectionPool(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize] 
         * @param {number} [maxTries] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaLoad1(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: any): AxiosPromise<ConsumerStatus> {
            return localVarFp.generateKafkaLoad1(topicName, server, batchSize, maxTries, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [indexName]
         * @param {number} [startId]
         * @param {number} [endId]
         * @param {number} [batchSize]
         * @param {string} [dataClass]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOpenSearchLoad1(indexName?: string, startId?: number, endId?: number, batchSize?: number, dataClass?: string, options?: any): AxiosPromise<ConsumerStatus> {
            return localVarFp.generateOpenSearchLoad1(indexName, startId, endId, batchSize, dataClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestConsumerControllerApi - object-oriented interface
 * @export
 * @class RestConsumerControllerApi
 * @extends {BaseAPI}
 */
export class RestConsumerControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConsumerControllerApi
     */
    public cleanKafkaConnectionPool1(options?: RawAxiosRequestConfig) {
        return RestConsumerControllerApiFp(this.configuration).cleanKafkaConnectionPool1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConsumerControllerApi
     */
    public cleanOpenSearchConnectionPool(options?: RawAxiosRequestConfig) {
        return RestConsumerControllerApiFp(this.configuration).cleanOpenSearchConnectionPool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [topicName]
     * @param {number} [server]
     * @param {number} [batchSize] 
     * @param {number} [maxTries] 
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConsumerControllerApi
     */
    public generateKafkaLoad1(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return RestConsumerControllerApiFp(this.configuration).generateKafkaLoad1(topicName, server, batchSize, maxTries, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [indexName]
     * @param {number} [startId]
     * @param {number} [endId]
     * @param {number} [batchSize]
     * @param {string} [dataClass]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestConsumerControllerApi
     */
    public generateOpenSearchLoad1(indexName?: string, startId?: number, endId?: number, batchSize?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return RestConsumerControllerApiFp(this.configuration).generateOpenSearchLoad1(indexName, startId, endId, batchSize, dataClass, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RestInfoControllerApi - axios parameter creator
 * @export
 */
export const RestInfoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestInfoControllerApi - functional programming interface
 * @export
 */
export const RestInfoControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RestInfoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async about(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<About>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.about(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestInfoControllerApi.about']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RestInfoControllerApi - factory interface
 * @export
 */
export const RestInfoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestInfoControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about(options?: any): AxiosPromise<About> {
            return localVarFp.about(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestInfoControllerApi - object-oriented interface
 * @export
 * @class RestInfoControllerApi
 * @extends {BaseAPI}
 */
export class RestInfoControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestInfoControllerApi
     */
    public about(options?: RawAxiosRequestConfig) {
        return RestInfoControllerApiFp(this.configuration).about(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RestLogControllerApi - axios parameter creator
 * @export
 */
export const RestLogControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClass: async (className?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log/listClass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (className !== undefined) {
                localVarQueryParameter['className'] = className;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestLogControllerApi - functional programming interface
 * @export
 */
export const RestLogControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RestLogControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassStatistic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestLogControllerApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClass(className?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStatistic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClass(className, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestLogControllerApi.listClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RestLogControllerApi - factory interface
 * @export
 */
export const RestLogControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestLogControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<Array<ClassStatistic>> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClass(className?: string, options?: any): AxiosPromise<ClassStatistic> {
            return localVarFp.listClass(className, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestLogControllerApi - object-oriented interface
 * @export
 * @class RestLogControllerApi
 * @extends {BaseAPI}
 */
export class RestLogControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestLogControllerApi
     */
    public list(options?: RawAxiosRequestConfig) {
        return RestLogControllerApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [className] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestLogControllerApi
     */
    public listClass(className?: string, options?: RawAxiosRequestConfig) {
        return RestLogControllerApiFp(this.configuration).listClass(className, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RestProducerControllerApi - axios parameter creator
 * @export
 */
export const RestProducerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanKafkaConnectionPool: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/cleanKafkaConnectionPool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanOpenSearchConnection: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/cleanOpenSearchConnection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Array<string>} [topics] 
         * @param {number} [partitions] 
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKafkaTopics: async (topics?: Array<string>, partitions?: number, replication?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/createKafkaTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topics) {
                localVarQueryParameter['topics[]'] = topics;
            }

            if (partitions !== undefined) {
                localVarQueryParameter['partitions'] = partitions;
            }

            if (replication !== undefined) {
                localVarQueryParameter['replication'] = replication;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Array<string>} [indexes]
         * @param {number} [shards]
         * @param {number} [replicas]
         * @param {number} [refreshSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOpenSearchIndexes: async (indexes?: Array<string>, shards?: number, replicas?: number, refreshSeconds?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/createOpenSearchIndexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (indexes) {
                localVarQueryParameter['indexes[]'] = indexes;
            }

            if (shards !== undefined) {
                localVarQueryParameter['shards'] = shards;
            }

            if (replicas !== undefined) {
                localVarQueryParameter['replicas'] = replicas;
            }

            if (refreshSeconds !== undefined) {
                localVarQueryParameter['refreshSeconds'] = refreshSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKafkaTopics: async (topics?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/deleteKafkaTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topics) {
                localVarQueryParameter['topics[]'] = topics;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Array<string>} [indexes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOpenSearchIndexes: async (indexes?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/deleteOpenSearchIndexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (indexes) {
                localVarQueryParameter['indexes[]'] = indexes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaLoad: async (topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/generateKafkaLoad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (correlatedStartIdInc !== undefined) {
                localVarQueryParameter['correlatedStartIdInc'] = correlatedStartIdInc;
            }

            if (correlatedEndIdInc !== undefined) {
                localVarQueryParameter['correlatedEndIdInc'] = correlatedEndIdInc;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [indexName]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOpenSearchLoad: async (indexName?: string, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/generateOpenSearchLoad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (indexName !== undefined) {
                localVarQueryParameter['indexName'] = indexName;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (correlatedStartIdInc !== undefined) {
                localVarQueryParameter['correlatedStartIdInc'] = correlatedStartIdInc;
            }

            if (correlatedEndIdInc !== undefined) {
                localVarQueryParameter['correlatedEndIdInc'] = correlatedEndIdInc;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listDataTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaDataClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listKafkaDataClasses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaTopics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listKafkaTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOpenSearchDataClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listOpenSearchDataClasses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOpenSearchIndexes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listOpenSearchIndexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestProducerControllerApi - functional programming interface
 * @export
 */
export const RestProducerControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RestProducerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanKafkaConnectionPool(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanKafkaConnectionPool(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.cleanKafkaConnectionPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanOpenSearchConnection(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanOpenSearchConnection(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.cleanOpenSearchConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {Array<string>} [topics] 
         * @param {number} [partitions] 
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKafkaTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKafkaTopics(topics, partitions, replication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.createKafkaTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {Array<string>} [indexes]
         * @param {number} [shards]
         * @param {number} [replicas]
         * @param {number} [refreshSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOpenSearchIndexes(indexes?: Array<string>, shards?: number, replicas?: number, refreshSeconds?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOpenSearchIndexes(indexes, shards, replicas, refreshSeconds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.createOpenSearchIndexes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKafkaTopics(topics?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKafkaTopics(topics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.deleteKafkaTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {Array<string>} [indexes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOpenSearchIndexes(indexes?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOpenSearchIndexes(indexes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.deleteOpenSearchIndexes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKafkaLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKafkaLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.generateKafkaLoad']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [indexName]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateOpenSearchLoad(indexName?: string, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateOpenSearchLoad(indexName, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.generateOpenSearchLoad']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDataTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.listDataTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkaDataClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkaDataClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.listKafkaDataClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkaTopics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkaTopics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.listKafkaTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOpenSearchDataClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOpenSearchDataClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.listOpenSearchDataClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOpenSearchIndexes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOpenSearchIndexes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestProducerControllerApi.listOpenSearchIndexes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RestProducerControllerApi - factory interface
 * @export
 */
export const RestProducerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestProducerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanKafkaConnectionPool(options?: any): AxiosPromise<string> {
            return localVarFp.cleanKafkaConnectionPool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanOpenSearchConnection(options?: any): AxiosPromise<string> {
            return localVarFp.cleanOpenSearchConnection(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<string>} [topics] 
         * @param {number} [partitions] 
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKafkaTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: any): AxiosPromise<object> {
            return localVarFp.createKafkaTopics(topics, partitions, replication, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<string>} [indexes]
         * @param {number} [shards]
         * @param {number} [replicas]
         * @param {number} [refreshSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOpenSearchIndexes(indexes?: Array<string>, shards?: number, replicas?: number, refreshSeconds?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.createOpenSearchIndexes(indexes, shards, replicas, refreshSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKafkaTopics(topics?: Array<string>, options?: any): AxiosPromise<object> {
            return localVarFp.deleteKafkaTopics(topics, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<string>} [indexes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOpenSearchIndexes(indexes?: Array<string>, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteOpenSearchIndexes(indexes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc] 
         * @param {number} [correlatedEndIdInc] 
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: any): AxiosPromise<ProducerStatus> {
            return localVarFp.generateKafkaLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [indexName]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOpenSearchLoad(indexName?: string, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: any): AxiosPromise<ProducerStatus> {
            return localVarFp.generateOpenSearchLoad(indexName, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataTypes(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listDataTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaDataClasses(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listKafkaDataClasses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaTopics(options?: any): AxiosPromise<Set<string>> {
            return localVarFp.listKafkaTopics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOpenSearchDataClasses(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listOpenSearchDataClasses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOpenSearchIndexes(options?: any): AxiosPromise<Set<string>> {
            return localVarFp.listOpenSearchIndexes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestProducerControllerApi - object-oriented interface
 * @export
 * @class RestProducerControllerApi
 * @extends {BaseAPI}
 */
export class RestProducerControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public cleanKafkaConnectionPool(options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).cleanKafkaConnectionPool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public cleanOpenSearchConnection(options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).cleanOpenSearchConnection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Array<string>} [topics] 
     * @param {number} [partitions] 
     * @param {number} [replication] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public createKafkaTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).createKafkaTopics(topics, partitions, replication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Array<string>} [indexes]
     * @param {number} [shards]
     * @param {number} [replicas]
     * @param {number} [refreshSeconds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public createOpenSearchIndexes(indexes?: Array<string>, shards?: number, replicas?: number, refreshSeconds?: number, options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).createOpenSearchIndexes(indexes, shards, replicas, refreshSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [topics] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public deleteKafkaTopics(topics?: Array<string>, options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).deleteKafkaTopics(topics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Array<string>} [indexes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public deleteOpenSearchIndexes(indexes?: Array<string>, options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).deleteOpenSearchIndexes(indexes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [topicName]
     * @param {number} [server]
     * @param {number} [batchSize]
     * @param {number} [startId]
     * @param {number} [correlatedStartIdInc] 
     * @param {number} [correlatedEndIdInc] 
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public generateKafkaLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).generateKafkaLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [indexName]
     * @param {number} [batchSize]
     * @param {number} [startId]
     * @param {number} [correlatedStartIdInc]
     * @param {number} [correlatedEndIdInc]
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public generateOpenSearchLoad(indexName?: string, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).generateOpenSearchLoad(indexName, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public listDataTypes(options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).listDataTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public listKafkaDataClasses(options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).listKafkaDataClasses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public listKafkaTopics(options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).listKafkaTopics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public listOpenSearchDataClasses(options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).listOpenSearchDataClasses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestProducerControllerApi
     */
    public listOpenSearchIndexes(options?: RawAxiosRequestConfig) {
        return RestProducerControllerApiFp(this.configuration).listOpenSearchIndexes(options).then((request) => request(this.axios, this.basePath));
    }
}



