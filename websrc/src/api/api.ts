/* tslint:disable */
/* eslint-disable */
/**
 * kafka_executor
 * This customizable load generator will create producers and consumers. Features include controllable parallel execution of different workloads. There is an easy-to-use Swagger front end that can be used to integrate with other programming languages such as React, Angular, Python... The intention is to use JMeter or even siege to run and monitor the tests using simple http calls. 
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type {Configuration} from './configuration';
import type {AxiosInstance, AxiosPromise, RawAxiosRequestConfig} from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
    assertParamExists,
    createRequestFunction,
    DUMMY_BASE_URL,
    serializeDataIfNeeded,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    toPathString
} from './common';
import type {RequestArgs} from './base';
// @ts-ignore
import {BASE_PATH, BaseAPI, COLLECTION_FORMATS, operationServerMap, RequiredError} from './base';

/**
 * 
 * @export
 * @interface About
 */
export interface About {
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'Version'?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    'CurrentDateTime'?: string;
}
/**
 * 
 * @export
 * @interface BatchStatus
 */
export interface BatchStatus {
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'CurrentDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'BatchName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatus
     */
    'BatchType'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchStatus
     */
    'RunningJobs'?: number;
}
/**
 * 
 * @export
 * @interface ClassStatistic
 */
export interface ClassStatistic {
    /**
     * 
     * @type {string}
     * @memberof ClassStatistic
     */
    'className'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'consumerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'consumerAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'producerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassStatistic
     */
    'producerAmount'?: number;
}
/**
 * 
 * @export
 * @interface ConsumerStatus
 */
export interface ConsumerStatus {
    /**
     *
     * @type {string}
     * @memberof ConsumerStatus
     */
    'CurrentDateTime'?: string;
    /**
     *
     * @type {boolean}
     * @memberof ConsumerStatus
     */
    'Error'?: boolean;
    /**
     *
     * @type {string}
     * @memberof ConsumerStatus
     */
    'ErrorMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConsumerStatus
     */
    'Status'?: string;
    /**
     *
     * @type {number}
     * @memberof ConsumerStatus
     */
    'Count'?: number;
}

/**
 *
 * @export
 * @interface KafkaConnectionConfigDTO
 */
export interface KafkaConnectionConfigDTO {
    /**
     *
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'port'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'cert_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'truststore_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'keystore_location'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'schemaRegistryHost'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'schemaRegistryPort'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'schemaRegistryUser'?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'schemaRegistryPassword'?: string;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'producerLingerMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'producerBatchSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'compressionType'?: KafkaConnectionConfigDTOCompressionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'bufferMemory'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof KafkaConnectionConfigDTO
     */
    'idempotenceEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KafkaConnectionConfigDTO
     */
    'acks'?: KafkaConnectionConfigDTOAcksEnum;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'maxPollRecords'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'fetchMinByes'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'fetchMaxWaitMS'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'sessionTimeoutMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'heartbeatTimeoutMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof KafkaConnectionConfigDTO
     */
    'autoCommitIntervalMs'?: number;
}

export const KafkaConnectionConfigDTOCompressionTypeEnum = {
    None: 'none',
    Gzip: 'gzip',
    Snappy: 'snappy',
    Lz4: 'lz4',
    Zstd: 'zstd'
} as const;

export type KafkaConnectionConfigDTOCompressionTypeEnum = typeof KafkaConnectionConfigDTOCompressionTypeEnum[keyof typeof KafkaConnectionConfigDTOCompressionTypeEnum];
export const KafkaConnectionConfigDTOAcksEnum = {
    All: 'all',
    _1: '1',
    _0: '0'
} as const;

export type KafkaConnectionConfigDTOAcksEnum = typeof KafkaConnectionConfigDTOAcksEnum[keyof typeof KafkaConnectionConfigDTOAcksEnum];

/**
 * 
 * @export
 * @interface ProducerStatus
 */
export interface ProducerStatus {
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'CurrentDateTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProducerStatus
     */
    'Error'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'ErrorMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProducerStatus
     */
    'Status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProducerStatus
     */
    'Count'?: number;
}

/**
 * BatchControllerApi - axios parameter creator
 * @export
 */
export const BatchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/batchStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [taskName]
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeKafkaConsumerTaskCount: async (taskName?: string, numThreads?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/changeKafkaConsumerTaskCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [taskName]
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeKafkaProducerTaskCount: async (taskName?: string, numThreads?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/changeKafkaProducerTaskCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropKafkaConsumerTask: async (taskName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/dropKafkaConsumerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [taskName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropKafkaProducerTask: async (taskName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/dropKafkaProducerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskName !== undefined) {
                localVarQueryParameter['taskName'] = taskName;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [maxTries]
         * @param {number} [sleepMillis]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaConsumerTask: async (topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/generateKafkaConsumerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (maxTries !== undefined) {
                localVarQueryParameter['maxTries'] = maxTries;
            }

            if (sleepMillis !== undefined) {
                localVarQueryParameter['sleepMillis'] = sleepMillis;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {number} [sleepMillis]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaProducerTask: async (topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/generateKafkaProducerTask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (numThreads !== undefined) {
                localVarQueryParameter['numThreads'] = numThreads;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (correlatedStartIdInc !== undefined) {
                localVarQueryParameter['correlatedStartIdInc'] = correlatedStartIdInc;
            }

            if (correlatedEndIdInc !== undefined) {
                localVarQueryParameter['correlatedEndIdInc'] = correlatedEndIdInc;
            }

            if (sleepMillis !== undefined) {
                localVarQueryParameter['sleepMillis'] = sleepMillis;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaConsumers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/listKafkaConsumers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaProducers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/listKafkaProducers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batch/stopAllTasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchControllerApi - functional programming interface
 * @export
 */
export const BatchControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BatchStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.batchStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [taskName]
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeKafkaConsumerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeKafkaConsumerTaskCount(taskName, numThreads, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.changeKafkaConsumerTaskCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [taskName]
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeKafkaProducerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeKafkaProducerTaskCount(taskName, numThreads, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.changeKafkaProducerTaskCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [taskName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropKafkaConsumerTask(taskName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropKafkaConsumerTask(taskName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.dropKafkaConsumerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [taskName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropKafkaProducerTask(taskName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropKafkaProducerTask(taskName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.dropKafkaProducerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [maxTries]
         * @param {number} [sleepMillis]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKafkaConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKafkaConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.generateKafkaConsumerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {number} [sleepMillis]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKafkaProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKafkaProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.generateKafkaProducerTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkaConsumers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkaConsumers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.listKafkaConsumers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkaProducers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkaProducers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.listKafkaProducers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopAllTasks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopAllTasks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchControllerApi.stopAllTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchControllerApi - factory interface
 * @export
 */
export const BatchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchControllerApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchStatus(options?: any): AxiosPromise<Array<BatchStatus>> {
            return localVarFp.batchStatus(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [taskName]
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeKafkaConsumerTaskCount(taskName?: string, numThreads?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.changeKafkaConsumerTaskCount(taskName, numThreads, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [taskName]
         * @param {number} [numThreads] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeKafkaProducerTaskCount(taskName?: string, numThreads?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.changeKafkaProducerTaskCount(taskName, numThreads, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [taskName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropKafkaConsumerTask(taskName?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.dropKafkaConsumerTask(taskName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [taskName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropKafkaProducerTask(taskName?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.dropKafkaProducerTask(taskName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [maxTries]
         * @param {number} [sleepMillis]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.generateKafkaConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [numThreads]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {number} [sleepMillis]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.generateKafkaProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaConsumers(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listKafkaConsumers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaProducers(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listKafkaProducers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks(options?: any): AxiosPromise<string> {
            return localVarFp.stopAllTasks(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchControllerApi - object-oriented interface
 * @export
 * @class BatchControllerApi
 * @extends {BaseAPI}
 */
export class BatchControllerApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public batchStatus(options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).batchStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [taskName]
     * @param {number} [numThreads] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public changeKafkaConsumerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).changeKafkaConsumerTaskCount(taskName, numThreads, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [taskName]
     * @param {number} [numThreads] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public changeKafkaProducerTaskCount(taskName?: string, numThreads?: number, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).changeKafkaProducerTaskCount(taskName, numThreads, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [taskName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public dropKafkaConsumerTask(taskName?: string, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).dropKafkaConsumerTask(taskName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [taskName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public dropKafkaProducerTask(taskName?: string, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).dropKafkaProducerTask(taskName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [topicName]
     * @param {number} [numThreads]
     * @param {number} [batchSize]
     * @param {number} [maxTries]
     * @param {number} [sleepMillis]
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public generateKafkaConsumerTask(topicName?: string, numThreads?: number, batchSize?: number, maxTries?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).generateKafkaConsumerTask(topicName, numThreads, batchSize, maxTries, sleepMillis, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [topicName]
     * @param {number} [numThreads]
     * @param {number} [batchSize]
     * @param {number} [startId]
     * @param {number} [correlatedStartIdInc]
     * @param {number} [correlatedEndIdInc]
     * @param {number} [sleepMillis]
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public generateKafkaProducerTask(topicName?: string, numThreads?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, sleepMillis?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).generateKafkaProducerTask(topicName, numThreads, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, sleepMillis, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public listKafkaConsumers(options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).listKafkaConsumers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public listKafkaProducers(options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).listKafkaProducers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchControllerApi
     */
    public stopAllTasks(options?: RawAxiosRequestConfig) {
        return BatchControllerApiFp(this.configuration).stopAllTasks(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfigControllerApi - axios parameter creator
 * @export
 */
export const ConfigControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaAckTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/kafkaAckTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaCompressionTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/kafkaCompressionTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {KafkaConnectionConfigDTO} kafkaConnectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaConnection: async (kafkaConnectionConfigDTO: KafkaConnectionConfigDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kafkaConnectionConfigDTO' is not null or undefined
            assertParamExists('kafkaConnection', 'kafkaConnectionConfigDTO', kafkaConnectionConfigDTO)
            const localVarPath = `/server/kafkaConnection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kafkaConnectionConfigDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaConnection1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/kafkaConnection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigControllerApi - functional programming interface
 * @export
 */
export const ConfigControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kafkaAckTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{
            [key: string]: string;
        }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kafkaAckTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigControllerApi.kafkaAckTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kafkaCompressionTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kafkaCompressionTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigControllerApi.kafkaCompressionTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {KafkaConnectionConfigDTO} kafkaConnectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kafkaConnection(kafkaConnectionConfigDTO: KafkaConnectionConfigDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kafkaConnection(kafkaConnectionConfigDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigControllerApi.kafkaConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kafkaConnection1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KafkaConnectionConfigDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kafkaConnection1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigControllerApi.kafkaConnection1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigControllerApi - factory interface
 * @export
 */
export const ConfigControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaAckTypes(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.kafkaAckTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaCompressionTypes(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.kafkaCompressionTypes(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {KafkaConnectionConfigDTO} kafkaConnectionConfigDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaConnection(kafkaConnectionConfigDTO: KafkaConnectionConfigDTO, options?: any): AxiosPromise<void> {
            return localVarFp.kafkaConnection(kafkaConnectionConfigDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kafkaConnection1(options?: any): AxiosPromise<KafkaConnectionConfigDTO> {
            return localVarFp.kafkaConnection1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigControllerApi - object-oriented interface
 * @export
 * @class ConfigControllerApi
 * @extends {BaseAPI}
 */
export class ConfigControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public kafkaAckTypes(options?: RawAxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).kafkaAckTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public kafkaCompressionTypes(options?: RawAxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).kafkaCompressionTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {KafkaConnectionConfigDTO} kafkaConnectionConfigDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public kafkaConnection(kafkaConnectionConfigDTO: KafkaConnectionConfigDTO, options?: RawAxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).kafkaConnection(kafkaConnectionConfigDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public kafkaConnection1(options?: RawAxiosRequestConfig) {
        return ConfigControllerApiFp(this.configuration).kafkaConnection1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConsumerControllerApi - axios parameter creator
 * @export
 */
export const ConsumerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanKafkaConnectionPool1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/cleanKafkaConnectionPool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [maxTries]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaLoad1: async (topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/consumer/generateKafkaLoad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (maxTries !== undefined) {
                localVarQueryParameter['maxTries'] = maxTries;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsumerControllerApi - functional programming interface
 * @export
 */
export const ConsumerControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsumerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanKafkaConnectionPool1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanKafkaConnectionPool1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumerControllerApi.cleanKafkaConnectionPool1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [maxTries]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKafkaLoad1(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsumerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKafkaLoad1(topicName, server, batchSize, maxTries, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsumerControllerApi.generateKafkaLoad1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConsumerControllerApi - factory interface
 * @export
 */
export const ConsumerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsumerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanKafkaConnectionPool1(options?: any): AxiosPromise<string> {
            return localVarFp.cleanKafkaConnectionPool1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [maxTries]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaLoad1(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: any): AxiosPromise<ConsumerStatus> {
            return localVarFp.generateKafkaLoad1(topicName, server, batchSize, maxTries, dataClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConsumerControllerApi - object-oriented interface
 * @export
 * @class ConsumerControllerApi
 * @extends {BaseAPI}
 */
export class ConsumerControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumerControllerApi
     */
    public cleanKafkaConnectionPool1(options?: RawAxiosRequestConfig) {
        return ConsumerControllerApiFp(this.configuration).cleanKafkaConnectionPool1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [topicName]
     * @param {number} [server]
     * @param {number} [batchSize]
     * @param {number} [maxTries]
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumerControllerApi
     */
    public generateKafkaLoad1(topicName?: string, server?: number, batchSize?: number, maxTries?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return ConsumerControllerApiFp(this.configuration).generateKafkaLoad1(topicName, server, batchSize, maxTries, dataClass, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoControllerApi - axios parameter creator
 * @export
 */
export const InfoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoControllerApi - functional programming interface
 * @export
 */
export const InfoControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async about(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<About>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.about(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoControllerApi.about']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoControllerApi - factory interface
 * @export
 */
export const InfoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about(options?: any): AxiosPromise<About> {
            return localVarFp.about(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoControllerApi - object-oriented interface
 * @export
 * @class InfoControllerApi
 * @extends {BaseAPI}
 */
export class InfoControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoControllerApi
     */
    public about(options?: RawAxiosRequestConfig) {
        return InfoControllerApiFp(this.configuration).about(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogControllerApi - axios parameter creator
 * @export
 */
export const LogControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClass: async (className?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log/listClass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (className !== undefined) {
                localVarQueryParameter['className'] = className;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogControllerApi - functional programming interface
 * @export
 */
export const LogControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = LogControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassStatistic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogControllerApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClass(className?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStatistic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClass(className, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogControllerApi.listClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogControllerApi - factory interface
 * @export
 */
export const LogControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<Array<ClassStatistic>> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [className] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClass(className?: string, options?: any): AxiosPromise<ClassStatistic> {
            return localVarFp.listClass(className, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogControllerApi - object-oriented interface
 * @export
 * @class LogControllerApi
 * @extends {BaseAPI}
 */
export class LogControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public list(options?: RawAxiosRequestConfig) {
        return LogControllerApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [className] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public listClass(className?: string, options?: RawAxiosRequestConfig) {
        return LogControllerApiFp(this.configuration).listClass(className, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProducerControllerApi - axios parameter creator
 * @export
 */
export const ProducerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanKafkaConnectionPool: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/cleanKafkaConnectionPool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Array<string>} [topics]
         * @param {number} [partitions]
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKafkaTopics: async (topics?: Array<string>, partitions?: number, replication?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/createKafkaTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topics) {
                localVarQueryParameter['topics[]'] = topics;
            }

            if (partitions !== undefined) {
                localVarQueryParameter['partitions'] = partitions;
            }

            if (replication !== undefined) {
                localVarQueryParameter['replication'] = replication;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKafkaTopics: async (topics?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/deleteKafkaTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topics) {
                localVarQueryParameter['topics[]'] = topics;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaLoad: async (topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/generateKafkaLoad`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }

            if (startId !== undefined) {
                localVarQueryParameter['startId'] = startId;
            }

            if (correlatedStartIdInc !== undefined) {
                localVarQueryParameter['correlatedStartIdInc'] = correlatedStartIdInc;
            }

            if (correlatedEndIdInc !== undefined) {
                localVarQueryParameter['correlatedEndIdInc'] = correlatedEndIdInc;
            }

            if (dataClass !== undefined) {
                localVarQueryParameter['dataClass'] = dataClass;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listDataTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaDataClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listKafkaDataClasses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaTopics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/producer/listKafkaTopics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProducerControllerApi - functional programming interface
 * @export
 */
export const ProducerControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ProducerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanKafkaConnectionPool(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanKafkaConnectionPool(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.cleanKafkaConnectionPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {Array<string>} [topics]
         * @param {number} [partitions]
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKafkaTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKafkaTopics(topics, partitions, replication, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.createKafkaTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKafkaTopics(topics?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKafkaTopics(topics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.deleteKafkaTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateKafkaLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProducerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateKafkaLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.generateKafkaLoad']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDataTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.listDataTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkaDataClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkaDataClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.listKafkaDataClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKafkaTopics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKafkaTopics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProducerControllerApi.listKafkaTopics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProducerControllerApi - factory interface
 * @export
 */
export const ProducerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProducerControllerApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanKafkaConnectionPool(options?: any): AxiosPromise<string> {
            return localVarFp.cleanKafkaConnectionPool(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<string>} [topics]
         * @param {number} [partitions]
         * @param {number} [replication] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKafkaTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: any): AxiosPromise<object> {
            return localVarFp.createKafkaTopics(topics, partitions, replication, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKafkaTopics(topics?: Array<string>, options?: any): AxiosPromise<object> {
            return localVarFp.deleteKafkaTopics(topics, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [topicName]
         * @param {number} [server]
         * @param {number} [batchSize]
         * @param {number} [startId]
         * @param {number} [correlatedStartIdInc]
         * @param {number} [correlatedEndIdInc]
         * @param {string} [dataClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKafkaLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: any): AxiosPromise<ProducerStatus> {
            return localVarFp.generateKafkaLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataTypes(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listDataTypes(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaDataClasses(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listKafkaDataClasses(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKafkaTopics(options?: any): AxiosPromise<Set<string>> {
            return localVarFp.listKafkaTopics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProducerControllerApi - object-oriented interface
 * @export
 * @class ProducerControllerApi
 * @extends {BaseAPI}
 */
export class ProducerControllerApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public cleanKafkaConnectionPool(options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).cleanKafkaConnectionPool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Array<string>} [topics]
     * @param {number} [partitions]
     * @param {number} [replication] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public createKafkaTopics(topics?: Array<string>, partitions?: number, replication?: number, options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).createKafkaTopics(topics, partitions, replication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Array<string>} [topics] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public deleteKafkaTopics(topics?: Array<string>, options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).deleteKafkaTopics(topics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} [topicName]
     * @param {number} [server]
     * @param {number} [batchSize]
     * @param {number} [startId]
     * @param {number} [correlatedStartIdInc]
     * @param {number} [correlatedEndIdInc]
     * @param {string} [dataClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public generateKafkaLoad(topicName?: string, server?: number, batchSize?: number, startId?: number, correlatedStartIdInc?: number, correlatedEndIdInc?: number, dataClass?: string, options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).generateKafkaLoad(topicName, server, batchSize, startId, correlatedStartIdInc, correlatedEndIdInc, dataClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public listDataTypes(options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).listDataTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public listKafkaDataClasses(options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).listKafkaDataClasses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProducerControllerApi
     */
    public listKafkaTopics(options?: RawAxiosRequestConfig) {
        return ProducerControllerApiFp(this.configuration).listKafkaTopics(options).then((request) => request(this.axios, this.basePath));
    }
}



